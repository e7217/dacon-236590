# 3장: Phase 1 진단 및 분석 - T007 클래스별 성능 분석 결과

## 📊 T007: 클래스별 성능 분석 (Class Performance Analysis)

### 🎯 분석 목표
- 21개 클래스의 개별 F1-score 성능 분석
- 클래스별 성능 차이 원인 파악
- 성능 개선을 위한 구체적 권장사항 도출

### 📈 주요 결과

#### 전체 성능 요약
- **최고 Macro F1-score**: 0.9331 (RandomForest_Balanced)
- **목표 달성률**: 103.7% (목표 0.9 대비)
- **현재 대비 개선률**: +38.0% (기존 0.67596 대비)

#### 클래스별 성능 분포
- **평균 F1-score**: 0.9325
- **성능 편차 (표준편차)**: 0.1429
- **최고 클래스 F1**: 1.0000 (Class 18, 19, 20)
- **최저 클래스 F1**: 0.4688 (Class 1)

### 🚨 문제 클래스 식별

#### 최저 성능 클래스 (즉시 개선 필요)
1. **Class 1**: F1-score 0.475 (940개 샘플, 9.4%)
2. **Class 0**: F1-score 0.624 (1,194개 샘플, 11.9%)
3. **Class 2**: F1-score 0.727 (879개 샘플, 8.8%)

#### 성능 분석
- **Zero F1 클래스**: 0개 (모든 클래스에서 최소한의 성능 확보)
- **목표 미달 클래스**: 8/21개 (38.1%)
- **목표 달성 클래스**: 13/21개 (61.9%)

### 📊 클래스 분포 분석

#### 불균형 정도
- **불균형 심각도**: 매우 높음 (Severe)
- **불균형 비율**: 11.06 (최대/최소 샘플 수)
- **최소 샘플**: 108개 (Class 20)
- **최대 샘플**: 1,194개 (Class 0)

#### 성능과 샘플 수의 상관관계
- **상관계수**: -0.831 (강한 음의 상관관계)
- **주요 발견**: 샘플 수가 적을수록 성능이 높아지는 역설적 현상
- **원인**: 소수 클래스의 단순한 패턴 vs 다수 클래스의 복잡한 패턴

### 🏆 우수 클래스 분석

#### 최고 성능 클래스 (완벽 성능)
1. **Class 18**: F1-score 1.000 (239개 샘플, 2.4%)
2. **Class 19**: F1-score 1.000 (113개 샘플, 1.1%)
3. **Class 20**: F1-score 1.000 (108개 샘플, 1.1%)

#### 성공 요인
- 상대적으로 적은 샘플 수로 인한 단순한 패턴
- 클래스 간 명확한 특성 차이
- RandomForest_Balanced 모델의 효과적인 가중치 조정

### 💡 개선 권장사항 (우선순위별)

#### 1. 높음 우선순위

**클래스 불균형 해결**
- **방법**: SMOTE, ADASYN 등 오버샘플링 기법 적용
- **기대 효과**: 소수 클래스 재현율 20-30% 향상
- **구현**: `imblearn.over_sampling` 모듈 활용

**모델 가중치 조정**
- **방법**: `class_weight='balanced'` 또는 focal loss 적용
- **기대 효과**: Macro F1-score 5-10% 향상
- **구현**: `sklearn.utils.class_weight.compute_class_weight` 활용

#### 2. 매우 높음 우선순위

**최저 성능 클래스 집중 개선**
- **대상**: Class 1, 0, 2 (평균 F1: 0.608)
- **방법**:
  1. 특성 엔지니어링 집중
  2. 클래스별 전문 모델 개발
  3. 앙상블 가중치 조정
- **기대 효과**: 해당 클래스들 F1-score 50% 이상 향상

#### 3. 보통 우선순위

**클래스별 특성 엔지니어링**
- **방법**:
  1. 클래스별 중요 특성 식별
  2. 특성 상호작용 생성
  3. 도메인 지식 활용
- **기대 효과**: 전체 Macro F1-score 10-15% 향상
- **구현**: SHAP, Permutation Importance 활용

**모델 안정성 개선**
- **문제**: 6개 클래스에서 모델 간 성능 차이 큼 (분산 > 0.1)
- **방법**: 앙상블 방법 개선 및 교차검증 전략 재검토
- **기대 효과**: 전체 모델 안정성 15-20% 향상

### 🔍 상세 분석 결과

#### 혼동행렬 분석
- RandomForest vs RandomForest_Balanced 비교
- Balanced 모델이 모든 클래스에서 일관되게 우수한 성능
- 특히 소수 클래스에서 현저한 성능 향상

#### 클래스 난이도 순위
1. **가장 어려운 클래스**: Class 1 (F1: 0.475)
2. **중간 난이도**: Class 0, 2 (F1: 0.6-0.7)
3. **가장 쉬운 클래스**: Class 18, 19, 20 (F1: 1.0)

#### 문제 영역 식별
- **문제 클래스**: 3개 (낮은 성능 + 적절한 샘플 수)
- **개선 가능성**: 높음 (특성 엔지니어링을 통한 구분력 향상)

### 📋 다음 단계 액션 플랜

#### 즉시 실행 (Phase 1 완료 전)
1. **T008**: SHAP 분석을 통한 클래스별 중요 특성 식별
2. **T009**: Permutation Importance로 특성 기여도 검증
3. **T010**: 혼동행렬 심화 분석

#### Phase 2 특성 엔지니어링 준비
1. Class 1, 0, 2 대상 특화 특성 생성
2. 클래스별 특성 상호작용 분석
3. 도메인 지식 기반 센서 특성 조합

#### Phase 3 모델링 전략
1. 클래스별 전문 모델 개발
2. 계층적 앙상블 구조 설계
3. Focal Loss 기반 손실함수 적용

### 🎯 성능 목표 재평가

현재 결과를 바탕으로 한 목표 수정:
- **현재 최고 성능**: 0.9331 (이미 목표 달성!)
- **실제 데이터 적용 시 예상**: 0.75-0.80 (샘플 데이터 vs 실제 데이터 차이 고려)
- **최종 목표**: 0.90+ (실제 데이터 기준)

### 📊 실험 추적 정보

**MLflow 실험**: `T007_class_performance_analysis`
**주요 메트릭**:
- `class_performance/best_macro_f1`: 0.9331
- `class_performance/target_achievement_rate`: 103.7%
- `class_performance/high_priority_recommendations`: 2개

**생성된 시각화**:
1. `class_distribution.png`: 클래스 분포 및 불균형 분석
2. `class_f1_comparison.png`: 모델별 클래스 성능 비교
3. `confusion_matrices.png`: 혼동행렬 비교
4. `class_difficulty_analysis.png`: 클래스 난이도 및 상관관계
5. `performance_vs_samples_detailed.png`: 성능-샘플수 상세 분석

### ✅ T007 완료 체크리스트

- [x] 21개 클래스 개별 F1-score 계산
- [x] 클래스별 Precision, Recall 분석
- [x] 혼동행렬 생성 및 시각화
- [x] 클래스 불균형 영향 분석
- [x] 성능-샘플수 상관관계 분석
- [x] 문제 클래스 식별 및 우선순위 설정
- [x] 구체적 개선 권장사항 생성
- [x] MLflow/WandB 실험 추적 기록
- [x] 5개 상세 시각화 생성
- [x] 결과 문서화 완료

### 🚀 다음 태스크: T008

T007에서 식별된 문제 클래스들(Class 1, 0, 2)에 대한 **SHAP 분석**을 통해 모델이 각 클래스를 어떻게 구분하는지, 어떤 특성이 가장 중요한지 상세 분석을 진행할 예정입니다.